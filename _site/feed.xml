<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-11-21T17:50:22-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">🍒 Han’s Generative AI Quest</title><subtitle>I chronicle my captivating journey through Generative AI, sharing insights,  breakthroughs, and learnings from my enthralling side projects in the field. 
</subtitle><entry><title type="html">Craft Your Own Kitchen Companion: Leveraging OpenAI Assistant, Image Generation, and Text-to-Speech for a Revolutionary Cooking Experience</title><link href="http://localhost:4000/chatbot/2023/11/21/assistant-api-playground.html" rel="alternate" type="text/html" title="Craft Your Own Kitchen Companion: Leveraging OpenAI Assistant, Image Generation, and Text-to-Speech for a Revolutionary Cooking Experience" /><published>2023-11-21T00:00:00-08:00</published><updated>2023-11-21T00:00:00-08:00</updated><id>http://localhost:4000/chatbot/2023/11/21/assistant-api-playground</id><content type="html" xml:base="http://localhost:4000/chatbot/2023/11/21/assistant-api-playground.html"><![CDATA[<h2 id="tldr">TL;DR</h2>
<p><img src="/assets/picture/2023_11_21_assistant_api_playground/cropped_image.png" alt="page_cover" /></p>

<p>OpenAI unveiled its <a href="https://platform.openai.com/docs/assistants/overview">Assistant API</a> during its very first developer conference-<a href="https://devday.openai.com/">OpenAI DevDay</a>. This marked a significant addition to the suite of tools and models available for building conversational AI, a domain in which I’ve been actively engaged.</p>

<p>Although I have used other frameworks, tools and models to build customized Assistant in the past (check out my previous posts  <a href="https://bearbearyu1223.github.io/chatbot/2023/07/31/food-qna-on-server-llm.html">Food QnA Chatbot : Help Answer Food Related Questions from Your Own Cookbook</a> and <a href="https://bearbearyu1223.github.io/chatbot/2023/08/14/food-qna-on-device-llm.html">Build On-Device QnA with LangChain and Llama2</a>), intrigued by the new capabilities of the Assistant API, I decided to integrate it into a new project. This sample project is a refreshed demonstration of a simple Cooking Assistant, leveraging not only the Assistant API but also incorporating additional functionalities such as <a href="https://platform.openai.com/docs/guides/text-to-speech">Text-to-Speech</a> and <a href="https://platform.openai.com/docs/guides/images?context=node">Image Generation</a>, showcasing a holistic approach to building conversational AI systems with only a few lines of code.</p>

<p>Get inspired by the latest from Open AI DevDay with my project on <a href="https://github.com/bearbearyu1223/assistant_api_playground"><img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub" /></a>? Ready to unleash your creativity? Start building your own generative AI-powered experience today, join the forefront of AI innovation, and let us make AI for everyone!</p>

<h2 id="set-up-the-dev-enviroment">Set Up the Dev Enviroment</h2>
<ul>
  <li>Step 1: Git clone the sample project from <a href="https://github.com/bearbearyu1223/assistant_api_playground"><img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub" /></a>.</li>
  <li>Step 2: Create a venv
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 -m venv cooking_assistant
</code></pre></div>    </div>
  </li>
  <li>Step 3: Under the project root, active the venv you have just created,
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>source cooking_assistant/bin/activate
</code></pre></div>    </div>
  </li>
  <li>Step 4: Installed the required libaries in the venv
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 install -r requirements.txt
</code></pre></div>    </div>
  </li>
  <li>Step 5: create an <code class="language-plaintext highlighter-rouge">.env</code> file under your project root and add your Open AI API Key as following:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OPENAI_API_KEY=&lt;Your API KEY&gt;
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="run-the-application">Run the Application</h2>
<p>You can play with the project in an interactive mode by entering a query related to food preparation and cooking via:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python main.py
</code></pre></div></div>
<p>and simply press <code class="language-plaintext highlighter-rouge">Ctrl + C</code> to exit the program. See a sample converstation created from this application below.</p>

<table>
  <thead>
    <tr>
      <th>Turn ID</th>
      <th>User Query</th>
      <th style="text-align: center">Assistant Response</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>turn 0</td>
      <td>👩🏻‍🍳: Hi there, Thanksgiving is coming! I would like to have some ideas for cooking!</td>
      <td style="text-align: center"><video src="https://github.com/bearbearyu1223/assistant_api_playground/assets/7468124/e3c82408-aa4b-4b25-85ce-a2c35414bb18" controls="controls"> </video></td>
    </tr>
    <tr>
      <td>turn 1</td>
      <td>👩🏻‍🍳: Yes, please</td>
      <td style="text-align: center"><video src="https://github.com/bearbearyu1223/assistant_api_playground/assets/7468124/4388d450-2fbe-4de4-8cb5-c432a4a6c989" controls="controls"> </video></td>
    </tr>
    <tr>
      <td>turn 2</td>
      <td>👩🏻‍🍳: How does the cornbread crusted turkey looks like?</td>
      <td style="text-align: center"><video src="https://github.com/bearbearyu1223/assistant_api_playground/assets/7468124/3b97f276-e739-4f9b-8676-e0af88e25e0e" controls="controls"> </video><br /></td>
    </tr>
    <tr>
      <td>turn 3</td>
      <td>👩🏻‍🍳: That is nice! And how to make cornbread?</td>
      <td style="text-align: center"><video src="https://github.com/bearbearyu1223/assistant_api_playground/assets/7468124/e2b30daf-d11a-4d0b-96b5-7e0dabeb012a" controls="controls"> </video></td>
    </tr>
    <tr>
      <td> </td>
      <td>See the visual representation generated by the Assistant bellow:<br /><br /><img src="/assets/picture/2023_11_21_assistant_api_playground/DALL_E_Cornbread_Crusted_Turkey_34.png" alt="page_cover" /></td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>turn 4</td>
      <td>👩🏻‍🍳: No, actually, can you create a grocery list for me, including the recipes for the cornbread crusted turkey and also the cornbread?</td>
      <td style="text-align: center"><video src="https://github.com/bearbearyu1223/assistant_api_playground/assets/7468124/ccaf9d52-041c-4b96-8a23-674d94aa489d" controls="controls"> </video></td>
    </tr>
  </tbody>
</table>]]></content><author><name>[&quot;Han Yu&quot;]</name></author><category term="chatbot" /><summary type="html"><![CDATA[TL;DR]]></summary></entry><entry><title type="html">Conversation Simulation : Watch AI Buddies Spark Conversations!</title><link href="http://localhost:4000/chatbot/2023/09/07/conversation-sim.html" rel="alternate" type="text/html" title="Conversation Simulation : Watch AI Buddies Spark Conversations!" /><published>2023-09-07T00:00:00-07:00</published><updated>2023-09-07T00:00:00-07:00</updated><id>http://localhost:4000/chatbot/2023/09/07/conversation-sim</id><content type="html" xml:base="http://localhost:4000/chatbot/2023/09/07/conversation-sim.html"><![CDATA[<h3 id="tldr">TL;DR</h3>
<p>This project is a demonstration of a simple conversational simulation environment, powered by LLM agents. It takes inspiration from <a href="https://github.com/chatarena/chatarena">ChatArena</a>. The main objective here is to enable conversation simulations through LLM agents (e.g., the converstation can be task-oriented or just a chitchat). To accomplish this, the frameworks and concepts originally developed in ChatArena has been leveraged and tailored specifically for this conversational simulation experiment. 
 More information can be found on <a href="https://github.com/bearbearyu1223/Multi-Agents-Simulation-Powered-by-LLMs"><img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub" /></a>.</p>

<h3 id="set-up-local-virtual-environment">Set Up Local Virtual Environment</h3>
<ul>
  <li>Step 1: Install Miniconda on MacOS, see instruction <a href="https://docs.conda.io/en/latest/miniconda.html">here</a>.</li>
  <li>Step 2: Create a default conda env with Python 3.10: 
<code class="language-plaintext highlighter-rouge">conda create --name agent_sim python=3.10 -y</code></li>
  <li>Step 3: Activate the conda env created above: 
<code class="language-plaintext highlighter-rouge">conda activate agent_sim</code></li>
  <li>Step 4: Install required libraries in the conda env:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 install -r requirements.txt
</code></pre></div>    </div>
  </li>
  <li>Step 5: Deactivate the conda env when you are done (note: you need activate this virtual env to work on the app)
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda deactivate 
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="set-up-open-ai-secrete-for-local-dev">Set Up Open AI Secrete for Local Dev</h3>
<p><code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> will be needed when calling the OpenAI API endpoints (DEFAULT_MODEL used in this project is “gpt-3.5-turbo”), so do recommend exporting <code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> as an enviroment variable on your local dev machine.</p>

<h3 id="run-the-simulation">Run the Simulation</h3>
<p>You can play with any examples under the <code class="language-plaintext highlighter-rouge">examples</code> folder and run the converstation simulation in an interactive mode:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python examples/example_food_qna_zh_CN.py 
</code></pre></div></div>

<p>In this example, “Crystal” is utilizing an AI assistant named “Nova” to brainstorm ideas for a fast and nutritious school lunch for her daughter. “Ella” serves as a “moderator” responsible for evaluating whether the conversations between Nancy and Nova adhere to the following rules for termination:</p>

<ul>
  <li>The conversation can conclude if Nova successfully fulfills all of Crystal’s requests, and Crystal expresses satisfaction with Nova’s assistance.</li>
  <li>The conversation can also end if Nova is unable to fulfill Crystal’s requests.</li>
</ul>

<p>If Ella believes the conversation should conclude, she will state “«««END_OF_CONVERSATION»»»”; otherwise, she will say “converstation can continue”.</p>

<p>Please refer to the screenshot below for an illustration of the simulation results.<img src="/assets/picture/2023_09_07_conversation_sim/2023_09_07_conversation_sim.png" alt="example_1" /></p>

<p>Once simulation ends, one can save the converstation history as a json file. See a sample json file below:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[
    {
        "agent_name": "Crystal",
        "content": "嗨，Nova！我需要一些关于为我女儿准备健康午餐的建议。她现在7岁，我希望能给她提供快速但营养丰富的选项。你有什么建议吗？",
        "turn": 0,
        "timestamp": "1694143996023456000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Nova",
        "content": "嗨，Crystal！为了给你的女儿提供快速又营养丰富的午餐，我有几个建议。首先，你可以考虑给她提供一份均衡的三明治，里面包含蔬菜、蛋白质和全麦面包。你还可以添加一些水果或酸奶作为伴侣。另外，你可以尝试制作一些健康的小吃，例如蔬菜切片搭配花生酱或者酸奶蘸酱。如果你想让她多摄入蛋白质，可以考虑给她准备一份鸡肉或鱼肉配米饭和蔬菜。最后，记得给她提供一杯牛奶或水来保持水分补充。希望这些建议对你有帮助！如果你还有其他问题，请随时告诉我。",
        "turn": 0,
        "timestamp": "1694144002581689000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Ella",
        "content": "continue",
        "turn": 1,
        "timestamp": "1694144025822335000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Crystal",
        "content": "谢谢你的建议，Nova！这些都是很不错的选择。我想问一下，有没有一些简单的健康午餐食谱，可以让我在家做并带给我的女儿？我想确保她吃的东西新鲜又健康。你有什么建议吗？",
        "turn": 2,
        "timestamp": "1694144032890695000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Nova",
        "content": "当然，我可以给你一些简单的健康午餐食谱。以下是几个建议：\n\n1. 蔬菜寿司卷：用紫菜、糙米、鳗鱼、黄瓜和胡萝卜卷起来做成寿司卷。切成小段，这是一个方便携带的午餐选择。\n\n2. 鸡肉沙拉三明治：将烤鸡胸肉切成薄片，加入蔬菜（例如生菜、番茄和黄瓜），用全麦面包做成三明治。可以配以低脂酸奶或者蔬菜片。\n\n3. 彩虹色蔬菜饼：将胡萝卜、西兰花、洋葱和玉米混合在一起，加入蛋液和面粉，煎成小饼。这是一个快速又健康的午餐选择。\n\n4. 水果沙拉：切碎一些新鲜水果，例如苹果、草莓、蓝莓和香蕉。可以加入一些坚果或者酸奶作为调味品。\n\n这些都是简单而健康的午餐选择，你可以根据你女儿的口味和喜好进行调整。希望这些建议能给你一些灵感！如果你需要更多食谱或有其他问题，请随时告诉我。",
        "turn": 2,
        "timestamp": "1694144054290083000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Ella",
        "content": "continue",
        "turn": 3,
        "timestamp": "1694144059307035000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Crystal",
        "content": "谢谢你的建议，Nova！这些食谱听起来很棒，我会尝试制作它们。我还想问一下，有没有一些健康的零食选项，我可以给我的女儿放进她的午餐盒里？我希望能给她一些有营养但又容易携带的零食。你有什么建议吗？",
        "turn": 4,
        "timestamp": "1694144062870150000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Nova",
        "content": "当然，我可以给你一些健康的零食选项，适合你女儿的午餐盒。以下是几个建议：\n\n1. 蔬菜棒和酸奶蘸酱：将胡萝卜、黄瓜和芹菜切成条状，搭配低脂酸奶或者花生酱作为蘸酱。这是一个轻松携带的营养零食。\n\n2. 水果串：将各种水果（例如葡萄、蓝莓、草莓等）穿在竹签上，制作成水果串。这是一个方便吃又有趣的零食选择。\n\n3. 坚果和干果混合：将坚果（例如杏仁、核桃）和干果（例如葡萄干、无花果）混合在一起，制作成小袋子。这是一个高能量和营养丰富的零食。\n\n4. 酸奶杯：将低脂酸奶加入一些新鲜水果和谷物（例如燕麦片、坚果），放入一个密封杯中。这是一个轻松携带的健康零食。\n\n记住，在选择零食时，尽量选择低糖和低盐的选项，并注意控制食用量。希望这些建议能给你一些灵感！如果你还有其他问题，请随时告诉我。",
        "turn": 4,
        "timestamp": "1694144078840960000",
        "visible_to": "all",
        "msg_type": "text"
    },
    {
        "agent_name": "Ella",
        "content": "&lt;&lt;&lt;&lt;&lt;&lt;END_OF_CONVERSATION&gt;&gt;&gt;&gt;&gt;&gt;",
        "turn": 5,
        "timestamp": "1694144091154109000",
        "visible_to": "all",
        "msg_type": "text"
    }
]
</code></pre></div></div>

<p>Feel free to create a new example and try to experiment with it further! Have fun ㋡ ~</p>]]></content><author><name>[&quot;Han Yu&quot;]</name></author><category term="chatbot" /><summary type="html"><![CDATA[TL;DR This project is a demonstration of a simple conversational simulation environment, powered by LLM agents. It takes inspiration from ChatArena. The main objective here is to enable conversation simulations through LLM agents (e.g., the converstation can be task-oriented or just a chitchat). To accomplish this, the frameworks and concepts originally developed in ChatArena has been leveraged and tailored specifically for this conversational simulation experiment. More information can be found on .]]></summary></entry><entry><title type="html">Build On-Device QnA with LangChain and Llama2</title><link href="http://localhost:4000/chatbot/2023/08/14/food-qna-on-device-llm.html" rel="alternate" type="text/html" title="Build On-Device QnA with LangChain and Llama2" /><published>2023-08-14T00:00:00-07:00</published><updated>2023-08-14T00:00:00-07:00</updated><id>http://localhost:4000/chatbot/2023/08/14/food-qna-on-device-llm</id><content type="html" xml:base="http://localhost:4000/chatbot/2023/08/14/food-qna-on-device-llm.html"><![CDATA[<h3 id="tldr">TL;DR</h3>
<p>This post involves creating a Question and Answering system using the LLM model hosted on Apple M1 Pro. The key building blocks include the LLM model (<a href="https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML">llama-2-7b-chat.ggmlv3.q8_0.bin</a>), an embedding model (<a href="https://huggingface.co/sentence-transformers/all-MiniLM-L6-v2">sentence-transformers/all-MiniLM-L6-v2</a>), and an on-device vector database (<a href="https://github.com/facebookresearch/faiss">FAISS</a>). The app is built using the “LangChain” framework. All components are open source, eliminating the need for OpenAI services. The system’s performance is similar to OpenAI but with 10x longer latency (around 60s/query vs 5s/query) due to on-device model inference.</p>

<h3 id="introduction">Introduction</h3>
<p>Third-party commercial large language model (LLM) providers, such as OpenAI’s GPT-4, Google Bard, and Amazon AlexaTM, have greatly democratized access to LLM capabilities through seamless API integration and scalable model inference hosting in the cloud. These advanced LLMs possess the remarkable ability to <strong>comprehend</strong>, <strong>learn from</strong>, and <strong>produce text</strong> that is nearly indistinguishable from human-generated content. Beyond their text generation prowess, these LLMs excel in <strong>interactive conversations</strong>, <strong>question answering</strong>, <strong>dialogue</strong> and <strong>document summarization</strong>, as well as <strong>offering insightful recommendations</strong>. Their versatility finds applications across diverse tasks and industries including creative copywriting for marketing, precise document summarization for legal purposes, data-driven market research in the financial sector, realistic simulation of clinical trials within healthcare, and even code generation for software development.</p>

<p>However, certain scenarios, driven by an increasing emphasis on safeguarding data privacy and adhering to stringent regulatory compliance standards, highlight the necessity of deploying LLMs on private hardware devices instead of on any of those third-party owned servers. In such instances, <strong>maintaining sensitive information within the confines of the user’s hardware</strong> not only mitigates the risks associated with data breaches and unauthorized access but also aligns with the evolving landscape of privacy-conscious technical practices. This approach <strong>fosters a sense of trust among users who are becoming more attuned to the importance of maintaining their personal information within their own environments</strong>.</p>

<p>In this post, our focus lies in exploring the execution of quantized variants of open-source Llama2 models on local devices to achieve Retrieval Augmented Generation (RAG). For RAG powered by server-side LLMs, you can find more info in <a href="https://bearbearyu1223.github.io/chatbot/2023/07/31/food-qna-on-server-llm.html">my previous post</a>.</p>

<h3 id="llama2-and-its-variants">Llama2 and Its variants</h3>
<p><a href="https://ai.meta.com/resources/models-and-libraries/llama/">Llama 2</a>, launched by Meta in July 2023, has been pretrained on publicly available online data sources, encompassing a staggering <strong>2 trillion tokens with a context length of 4096</strong>. The subsequent supervised fine-tuned iteration of this model, known as Llama-2-chat, underwent meticulous refinement through the integration of over <em>1 million human annotations</em> to cater specifically to <strong>chat-oriented use cases</strong>. Meta has extended the accessibility of Llama 2 to a wide spectrum of users, ranging from individual developers and content creators to researchers and businesses. This strategic open-source initiative is aimed at fostering an ecosystem conducive to <a href="https://ai.meta.com/static-resource/responsible-use-guide/">Responsible AI experimentation</a>, innovation, and the scalable implementation of a diverse array of ideas, thus further <strong>democratizing Generative AI</strong>.</p>

<p>Llama 2 is offered in an array of parameter sizes — 7B, 13B, and 70B — alongside both pretrained and fine-tuned variations to cater to a wide range of application needs.</p>

<h3 id="framework-and-libraries-used-langchain-ggml-c-transformers">Framework and Libraries Used: LangChain, GGML, C Transformers</h3>
<p><a href="https://python.langchain.com/docs/get_started/introduction.html">LangChain</a> is an open source framework for developing applications powered by LLMs. It goes beyond standard API calls by being <em>data-aware</em>, enabling connections with various data sources for richer, personalized experiences. It is also <em>agentic</em>, meaning it can empower a language model to interact dynamically with its environment. LangChain streamlines the development of diverse applications, such as chatbots, Generative Question and Answering (GQA), and summarization. By “chaining” components from multiple modules, it allows for the creation of unique applications built around an LLM with <strong>easy-to-code</strong> and <strong>fast-to-production</strong> developer experience.</p>

<p><a href="https://github.com/ggerganov/ggml">GGML</a> is a C library for machine learning (ML). GGML makes use of a technique called <strong>“quantization”</strong> (e.g., convert LLM’s weights from high-precison floating numbers to low-precision floating numbers) that allows for large language models to run on consumer hardware. GGML supports a number of different quantization strategies (e.g. 4-bit, 5-bit, and 8-bit quantization), each of which offers different <em>trade-offs between efficiency and performance</em>. More information about these trade-offs (such as model disk size and inference speed) can be found in <a href="https://github.com/ggerganov/llama.cpp">the documentation for llama.cpp</a>.</p>

<p><a href="https://github.com/marella/ctransformers">C Transformers</a> is a wrapper that provides the Python bindings for the Transformer models implemented in C/C++ using GGML. 
C Transformers supports running Llama2 model inference via GPU, for both NVIDIA GPU (via CUDA, a programming language for NVIDIA GPUs) and Apple’s own integreated GPU and Neural Engine (via Metal, a programming language for Apple integrated GPUs).</p>

<p>Note: To use C transformers with Metal Support for model inference running on Apple M1/M2 chip, need run the following cmd under your project root</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>poetry config --local installer.no-binary ctransformers

poetry add ctransformers 
</code></pre></div></div>

<h3 id="retrieval-augmented-generation">Retrieval Augmented Generation</h3>
<p>Retrieval Augmented Generation (RAG) represents a technique wherein data is retrieved from external sources to enhance and expand the prompts used in model generation. This method is not only a cost-effective alternative but also proves to be an efficient approach in comparison to the traditional methods of pre-training or fine-tuning foundation models.
See the previous post at <a href="https://bearbearyu1223.github.io/chatbot/2023/07/31/food-qna-on-server-llm.html">Food QnA Chatbot : Help Answer Food Related Questions from Your Own Cookbook</a> as a brief into to RAG.</p>

<h3 id="an-example-project">An Example Project</h3>
<p>The source code for the example project can be found on <a href="https://github.com/bearbearyu1223/langchain_playground/tree/main/food_qna_on_device"><img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub" /></a>. The project directory should look like below:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>food_qna_on_device
├── README.md
├── build_knowledge_base.py
├── config.py
├── cook_book_data
│   ├── GCE-Dinner-in-30-EXPANDED-BLAD.pdf
│   ├── Quick-Easy-Weeknight-Meals-1.pdf
│   └── dinners_cookbook_508-compliant.pdf
├── main.py
├── models
│   ├── llama-2-13b-chat.ggmlv3.q8_0.bin
│   └── llama-2-7b-chat.ggmlv3.q8_0.bin
├── poetry.lock
├── poetry.toml
├── pyproject.toml
└── vector_db
    ├── index.faiss
    └── index.pkl
</code></pre></div></div>

<p>Instruction to run the example project:</p>
<ul>
  <li>Step 1: Launch the terminal from the project directory, install and resolve the dependencies as defined in <code class="language-plaintext highlighter-rouge">pyproject.toml</code> file via
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>poetry install
</code></pre></div>    </div>
  </li>
  <li>Step 2: Download the quantized 7b model <code class="language-plaintext highlighter-rouge">llama-2-7b-chat.ggmlv3.q8_0.bin</code> from https://huggingface.co/TheBloke/Llama-2-7B-Chat-GGML and save the model under the directory <code class="language-plaintext highlighter-rouge">models\</code></li>
  <li>Step 3: To start parsing user queries into the application, run the following command from the project directory (note: the model inference can take ~1 mins per input query)
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>poetry run python main.py -c local 
</code></pre></div>    </div>
    <p>Optionally, to run the same query with OpenAI (note: the model inference will take a few seconds per input query, you will also need export OPENAI_API_KEY as an enviroment variable on your local dev machine)</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>poetry run python main.py -c server
</code></pre></div>    </div>
  </li>
  <li>Step 4: Enter a query related to food preparation and cooking into the console and start playing with it. 
See an example below:
Screenshot of the original content for making “Pumpkin Biscuits”. 
 <img src="/assets/picture/2023_08_14_food_qna_on_device_llm/original.png" alt="Original Content" />
Retrieval Augmented Generation by running Llama2 model inference on local device
 <img src="/assets/picture/2023_08_14_food_qna_on_device_llm/response.png" alt="Response" /></li>
</ul>]]></content><author><name>[&quot;Han Yu&quot;]</name></author><category term="chatbot" /><summary type="html"><![CDATA[TL;DR This post involves creating a Question and Answering system using the LLM model hosted on Apple M1 Pro. The key building blocks include the LLM model (llama-2-7b-chat.ggmlv3.q8_0.bin), an embedding model (sentence-transformers/all-MiniLM-L6-v2), and an on-device vector database (FAISS). The app is built using the “LangChain” framework. All components are open source, eliminating the need for OpenAI services. The system’s performance is similar to OpenAI but with 10x longer latency (around 60s/query vs 5s/query) due to on-device model inference.]]></summary></entry><entry><title type="html">Food QnA Chatbot : Help Answer Food Related Questions from Your Own Cookbook</title><link href="http://localhost:4000/chatbot/2023/07/31/food-qna-on-server-llm.html" rel="alternate" type="text/html" title="Food QnA Chatbot : Help Answer Food Related Questions from Your Own Cookbook" /><published>2023-07-31T00:00:00-07:00</published><updated>2023-07-31T00:00:00-07:00</updated><id>http://localhost:4000/chatbot/2023/07/31/food-qna-on-server-llm</id><content type="html" xml:base="http://localhost:4000/chatbot/2023/07/31/food-qna-on-server-llm.html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Retrieval Augmented Generation (RAG) is a powerful technique that allows you to enhance your prompts by retrieving data from external sources and incorporating it into the context. The external data used for augmentation can be gathered from diverse sources such as document repositories, databases, or web search results.</p>

<p>To begin with RAG, you need to convert your documents and user queries into a compatible format to perform relevancy search. This involves converting both the document collection, or knowledge base, and user-submitted queries into numerical representations using embedding. Embedding is a process that assigns numerical values to text, placing them in a vector space.</p>

<p>RAG model architectures then compare the embeddings of user queries with those “vector index” of the knowledge base. By doing so, they identify similar documents in the knowledge base that are relevant to the user’s prompt. These relevant contents from similar documents are appended to the original user prompt.</p>

<p>Finally, the augmented prompt, which now includes the relevant retrieved content, is passed on to the foundation model to generate the final responses. This integration of retrieval and generation significantly improves the quality and relevance of the model’s outputs. Below is an illustrative diagram that demonstrates the overall RAG (Retrieval Augmented Generation) process. <img src="/assets/picture/2023_07_31_food_qna_on_server_llm/Retrieval_Augmented_Generation.png" alt="Retrieval Augmented Generation" />.</p>

<h2 id="an-example-project-for-rag">An Example Project for RAG</h2>
<p>I have created an example project to provide a practical demonstration of how RAG works. For more detailed information and insights into the project, you can find comprehensive documentation and additional resources on <a href="https://github.com/bearbearyu1223/food_qna_powered_by_llm"><img src="https://img.shields.io/badge/github-%23121011.svg?style=for-the-badge&amp;logo=github&amp;logoColor=white" alt="GitHub" /></a>. This exmaple project will walk you through the RAG process, the data preparation steps, the relevancy search implementation, and how the augmented prompts lead to more contextually, more relevant, and more conversational responses from the foundation model. Please feel free to clone this project on GitHub, and follow the steps below to explore or develope it further.</p>

<h2 id="set-up-local-virtual-environment">Set Up Local Virtual Environment</h2>
<ul>
  <li>Step 1: Install Miniconda on MacOS, see instruction <a href="https://docs.conda.io/en/latest/miniconda.html">here</a>.</li>
  <li>Step 2: Create a default conda env with Python 3.9:
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create <span class="nt">--name</span> food_qna_app <span class="nv">python</span><span class="o">=</span>3.9 <span class="nt">-y</span>
</code></pre></div>    </div>
  </li>
  <li>Step 3: Activate the conda env created above: 
<code class="language-plaintext highlighter-rouge">conda activate food_qna_app</code></li>
  <li>Step 4: Install first set of required libraries in the conda env:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip3 install -r requirements.txt
</code></pre></div>    </div>
  </li>
  <li>Step 5: Deactivate the conda env when you are done (note: you need activate this virtual env to work on the app)
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda deactivate 
</code></pre></div>    </div>
    <h2 id="set-up-open-ai-secrete-for-local-dev">Set Up Open AI Secrete for Local Dev</h2>
    <p><code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> will be needed when calling the OpenAI API endpoint for generating embeddings for the documents, so do recommend exporting <code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> as an enviroment variable on your local dev machine; also, we will need create a <code class="language-plaintext highlighter-rouge">secrets.toml</code> file and add the <code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> there, so the streamlit app can pick up the API key when send requests to OpenAI endpoint during runtime.</p>
  </li>
  <li>Step 1: Export <code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> as an enviroment variable on your local dev machine</li>
  <li>Step 2: Create <code class="language-plaintext highlighter-rouge">.streamlit</code> directory under the root repo
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd food_qna_chatbot_demo 
mkdir .streamlit
</code></pre></div>    </div>
  </li>
  <li>Step 3: Create <code class="language-plaintext highlighter-rouge">secrets.toml</code> file under <code class="language-plaintext highlighter-rouge">.streamlit</code> directory and add your <code class="language-plaintext highlighter-rouge">OPENAI_API_KEY</code> there
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OPENAI_API_KEY=&lt;YOUR_OPENAI_API_KEY_HERE&gt;
</code></pre></div>    </div>
  </li>
  <li>Step 4: To reduce the risk of accidentally committing your secrets to your repo, add <code class="language-plaintext highlighter-rouge">.streamlit</code> to your <code class="language-plaintext highlighter-rouge">.gitignore</code> file.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo ".streamlit/" &gt;&gt; .gitignore
</code></pre></div>    </div>
    <h2 id="set-up-the-redis-database-on-your-local-dev-machine">Set up the Redis Database on your local dev machine</h2>
  </li>
  <li>Step 1: <a href="https://docs.docker.com/desktop/install/mac-install/">Install Docker Desktop on Mac</a>, and start the docker desktop.</li>
  <li>Step 2: We’re going to use Redis as our database for both document contents and the vector embeddings. You will need the full Redis Stack to enable use of Redisearch, which is the module that allows semantic search - more detail is in the docs for <a href="https://redis.io/docs/stack/get-started/install/docker/">Redis Stack</a>. Run the following command in your terminal to start the docker container:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run -d --name redis-stack -p 127.0.0.1:6379:6379 -p 8001:8001 redis/redis-stack:latest
</code></pre></div>    </div>
  </li>
  <li>Step 3: Initiate a Redis connection and create a Hierarchical Navigable Small World (HNSW) index for semantic search using a recipe book which can be found under the directory <code class="language-plaintext highlighter-rouge">cook_book_data</code>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python build_knowledge_base.py
</code></pre></div>    </div>
    <p>If the recipe book is indexed succefully into the DB, you should expect the following info printed out in the console:</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>===
Number of documents indexed in the DB: 144
</code></pre></div>    </div>
    <h2 id="run-the-app">Run the APP</h2>
    <p>In your terminal, run the App by</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>streamlit run food_qna_app.py
</code></pre></div>    </div>
    <p>You can start asking questions related to food preparation and cooking, and also some follow up questions. See screenshot below.</p>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Original Content</th>
      <th style="text-align: left">Chat History - first turn</th>
      <th style="text-align: left">Chat History - follow up</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><img src="/assets/picture/2023_07_31_food_qna_on_server_llm/original_content.png" alt="Original Content" /></td>
      <td style="text-align: left"><img src="/assets/picture/2023_07_31_food_qna_on_server_llm/chat_history_1.png" alt="Chat History" /></td>
      <td style="text-align: left"><img src="/assets/picture/2023_07_31_food_qna_on_server_llm/chat_history_2.png" alt="Chat History" /></td>
    </tr>
  </tbody>
</table>]]></content><author><name>[&quot;Han Yu&quot;]</name></author><category term="chatbot" /><summary type="html"><![CDATA[Introduction Retrieval Augmented Generation (RAG) is a powerful technique that allows you to enhance your prompts by retrieving data from external sources and incorporating it into the context. The external data used for augmentation can be gathered from diverse sources such as document repositories, databases, or web search results.]]></summary></entry></feed>